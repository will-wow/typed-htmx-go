package extempl

import (
	"time"

	"github.com/lithammer/dedent"

	"github.com/will-wow/typed-htmx-go/examples/web/layout/templ/layout"
	"github.com/will-wow/typed-htmx-go/examples/web/bulkupdate/form"
	"github.com/will-wow/typed-htmx-go/htmx"
	"github.com/will-wow/typed-htmx-go/htmx/swap"
)

var hx = htmx.NewTempl()

templ Page(users []form.UserModel) {
	@layout.Wrapper("Bulk Update", "bulk-update") {
		<h1>Bulk Update</h1>
		<p>
			This demo shows how to implement a common pattern where rows are selected and then bulk updated. This is accomplished by putting a form around a table, with checkboxes in the table, and then including the checked values in the form submission <code>(POST request)</code>:
		</p>
		<pre>
			<code class="language-go">
				{ dedent.Dedent(`
					templ table(users []form.UserModel) {
						<form
							id="checked-contacts"
							{ hx.Post("/examples/templ/bulk-update/")... }
							{ hx.SwapExtended(
								swap.New().Strategy(swap.OuterHTML).Settle(3 * time.Second),
							)... }
							{ hx.Target("#toast")... }
						>
							<h3>Select Rows And Activate Or Deactivate Below</h3>
							<table>
								<thead>
									<tr>
										<th>Name</th>
										<th>Email</th>
										<th>Active</th>
									</tr>
								</thead>
								<tbody id="tbody">
									for _, user := range users {
										<tr>
											<td>{ user.Name }</td>
											<td>{ user.Email }</td>
											<td>
												<input
													type="checkbox"
													name={ user.Email }
													if user.Active {
														checked
													}
												/>
											</td>
										</tr>
									}
								</tbody>
							</table>
							<input type="submit" value="Bulk Update"/>
							@UpdateToast("")
						</form>
					}
				`) }
			</code>
		</pre>
		<p>
			The server will bulk-update the statuses based on the values of the checkboxes. We respond with a small toast message about the update to inform the user, and use ARIA to politely announce the update for accessibility.
		</p>
		<pre>
			<code class="language-css">
				{ dedent.Dedent(`
					#toast.htmx-settling {
						opacity: 100;
					}

					#toast {
						background: #E1F0DA;
						opacity: 0;
						transition: opacity 3s ease-out;
					}
				`) }
			</code>
		</pre>
		<pre>
			<code class="language-go">
				{ dedent.Dedent(`
					templ UpdateToast(toast string) {
						<span
							id="toast"
							if toast != "" {
								aria-live="polite"
							}
						>
							{ toast }
						</span>
					}
				`) }
			</code>
		</pre>
		<p>
			The cool thing is that, because HTML form inputs already manage their own state, we donâ€™t need to re-render any part of the users table. The active users are already checked and the inactive ones unchecked!
		</p>
		<p>
			You can see a working example of this code below.
		</p>
		<p>
			<a
				href="https://github.com/will-wow/typed-htmx-go/tree/main/examples/templ/web/bulkupdate"
				target="_blank"
				rel="noopener"
			>
				Source
			</a>
		</p>
		<h2>Demo</h2>
		@table(users)
	}
}

templ table(users []form.UserModel) {
	<form
		id="checked-contacts"
		{ hx.Post("/examples/templ/bulk-update/")... }
		{ hx.SwapExtended(
			swap.New().Strategy(swap.OuterHTML).Settle(3 * time.Second),
		)... }
		{ hx.Target("#toast")... }
	>
		<h3>Select Rows And Activate Or Deactivate Below</h3>
		<table>
			<thead>
				<tr>
					<th>Name</th>
					<th>Email</th>
					<th>Active</th>
				</tr>
			</thead>
			<tbody id="tbody">
				for _, user := range users {
					<tr>
						<td>{ user.Name }</td>
						<td>{ user.Email }</td>
						<td>
							<input
								type="checkbox"
								name={ user.Email }
								if user.Active {
									checked
								}
							/>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<input type="submit" value="Bulk Update"/>
		@UpdateToast("")
	</form>
}

templ UpdateToast(toast string) {
	<span
		id="toast"
		if toast != "" {
			aria-live="polite"
		}
	>
		{ toast }
	</span>
}
