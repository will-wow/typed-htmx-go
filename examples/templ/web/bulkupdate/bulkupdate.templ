package bulkupdate

import (
	"time"

	"github.com/lithammer/dedent"

	"github.com/will-wow/typed-htmx-go/examples/templ/web/layout"
	"github.com/will-wow/typed-htmx-go/hx"
	"github.com/will-wow/typed-htmx-go/hx/swap"
)

templ page(users []userModel) {
	@layout.Base("Bulk Update", "bulk-update") {
		<h1>Bulk Update</h1>
		<p>
			This demo shows how to implement a common pattern where rows are selected and then bulk updated. This is accomplished by putting a form around a table, with checkboxes in the table, and then including the checked values in the form submission <code>(POST request)</code>:
		</p>
		<pre>
			{ dedent.Dedent(`
				templ table(users []userModel) {
					<form
						id="checked-contacts"
						{ hx.New().
						Post("/examples/bulk-update/").
						SwapExtended(
							swap.New().Strategy(swap.OuterHTML).Settle(3 * time.Second),
						).
						Target("#toast").
						Build()... }
					>
						<h3>Select Rows And Activate Or Deactivate Below</h3>
						<table>
							<thead>
								<tr>
									<th>Name</th>
									<th>Email</th>
									<th>Active</th>
								</tr>
							</thead>
							<tbody id="tbody">
								for _, user := range users {
									<tr>
										<td>{ user.name }</td>
										<td>{ user.email }</td>
										<td>
											<input
												type="checkbox"
												name={ user.email }
												if user.active {
													checked
												}
											/>
										</td>
									</tr>
								}
							</tbody>
						</table>
						<input type="submit" value="Bulk Update"/>
						@updateToast("")
					</form>
				}
			`) }
		</pre>
		<p>
			The server will bulk-update the statuses based on the values of the checkboxes. We respond with a small toast message about the update to inform the user, and use ARIA to politely announce the update for accessibility.
		</p>
		<pre>
			{ dedent.Dedent(`
				#toast.htmx-settling {
					opacity: 100;
				}

				#toast {
					background: #E1F0DA;
					opacity: 0;
					transition: opacity 3s ease-out;
				}
			`) }
		</pre>
		<pre>
			{ dedent.Dedent(`
				templ updateToast(toast string) {
					<span
						id="toast"
						if toast != "" {
							aria-live="polite"
						}
					>
						{ toast }
					</span>
				}
			`) }
		</pre>
		<p>
			The cool thing is that, because HTML form inputs already manage their own state, we donâ€™t need to re-render any part of the users table. The active users are already checked and the inactive ones unchecked!
		</p>
		<p>
			You can see a working example of this code below.
		</p>
		<h2>Demo</h2>
		@table(users)
	}
}

templ table(users []userModel) {
	<form
		id="checked-contacts"
		{ hx.New().
		Post("/examples/bulk-update/").
		SwapExtended(
			swap.New().Strategy(swap.OuterHTML).Settle(3 * time.Second),
		).
		Target("#toast").
		Build()... }
	>
		<h3>Select Rows And Activate Or Deactivate Below</h3>
		<table>
			<thead>
				<tr>
					<th>Name</th>
					<th>Email</th>
					<th>Active</th>
				</tr>
			</thead>
			<tbody id="tbody">
				for _, user := range users {
					<tr>
						<td>{ user.name }</td>
						<td>{ user.email }</td>
						<td>
							<input
								type="checkbox"
								name={ user.email }
								if user.active {
									checked
								}
							/>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<input type="submit" value="Bulk Update"/>
		@updateToast("")
	</form>
}

templ updateToast(toast string) {
	<span
		id="toast"
		if toast != "" {
			aria-live="polite"
		}
	>
		{ toast }
	</span>
}
